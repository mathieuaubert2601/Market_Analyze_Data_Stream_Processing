import time
import os
import streamlit as st
import pandas as pd
import plotly.graph_objects as go
import datetime
from rag_engine import get_answer
from src.config import TICKERS, HISTORY_PATH
import chromadb
from src.config import TICKERS, HISTORY_PATH, CHROMA_PATH, COLLECTION_NAME

# --- CONFIGURATION ---
st.set_page_config(
    page_title="Real-Time Market AI", 
    page_icon="ğŸ“ˆ", 
    layout="wide",
    initial_sidebar_state="expanded"
)

st.title("âš¡ Real-Time Financial Market Analyst")

# --- UTILITY FUNCTIONS ---
def fmt_relative(ts: float) -> str:
    """Formats timestamp into 'X min ago'."""
    if not ts: 
        return "n/a"
    try:
        delta = max(int(time.time() - float(ts)), 0)
        if delta < 60: 
            return f"{delta}s ago"
        if delta < 3600: 
            return f"{delta // 60}m ago"
        if delta < 86400: 
            return f"{delta // 3600}h ago"
        return f"{delta // 86400}d ago"
    except:
        return "n/a"

def fmt(val):
    """Format numeric values with 2 decimal places."""
    if val is None or val == 'N/A' or val != val:
        return "N/A"
    try:
        return f"{float(val):.2f}"
    except:
        return str(val)

def check_system_health() -> tuple[str, str]:
    """Checks if the Consumer is actively writing to the heartbeat file."""
    heartbeat_file = os.path. join(HISTORY_PATH, "consumer_heartbeat.txt")
    status = "ğŸ”´ OFFLINE"
    color = "red"
    
    if os.path.exists(heartbeat_file):
        try:
            with open(heartbeat_file, "r") as f:
                last_beat = float(f.read().strip())
            
            delta = time.time() - last_beat
            if delta < 120:
                status = "ğŸŸ¢ ONLINE"
                color = "green"
            else:
                status = f"ğŸŸ  LAGGING ({int(delta)}s)"
                color = "orange"
        except:
            pass
    
    return status, color

def display_stock_chart(ticker: str) -> None:
    """Reads the local CSV history (generated by Kafka) and plots it with both MA50 and MA200."""
    csv_file = os.path.join(HISTORY_PATH, f"{ticker}.csv")

    if not os.path.exists(csv_file):
        st.info(f"â³ Waiting for Kafka stream to populate data for {ticker}...")
        return

    try:
        # âœ… Lire le CSV
        data = pd.read_csv(csv_file)
        
        # âœ… La premiÃ¨re colonne est l'index (date)
        if data.columns[0] != "date":
            data = data. rename(columns={data.columns[0]: "date"})
        
        data = data.set_index("date")
        data.index = pd.to_datetime(data.index, errors='coerce')
        
        # âœ… Normaliser et convertir les colonnes en numÃ©riques
        data.columns = [col.strip().capitalize() for col in data.columns]
        
        # Convertir en float (remplace les erreurs par NaN)
        for col in ["Open", "High", "Low", "Close", "Volume"]:
            if col in data.columns:
                data[col] = pd.to_numeric(data[col], errors='coerce')
        
        # Supprimer les lignes avec NaN
        data = data.dropna(subset=["Open", "High", "Low", "Close"])
        
        if data.empty: 
            st. warning("ğŸ“Š CSV vide ou donnÃ©es invalides")
            return

        # Candle Chart
        fig = go.Figure(data=[go.Candlestick(
            x=data.index,
            open=data["Open"],
            high=data["High"],
            low=data["Low"],
            close=data["Close"],
            name=ticker
        )])

        # Moving Average 50j
        if len(data) > 50:
            ma50 = data["Close"].rolling(window=50).mean()
            fig.add_trace(go.Scatter(
                x=data.index, 
                y=ma50, 
                mode="lines", 
                name="MA 50", 
                line=dict(color="orange", width=2)
            ))

        # Moving Average 200j
        if len(data) > 200:
            ma200 = data["Close"].rolling(window=200).mean()
            fig.add_trace(go.Scatter(
                x=data.index, 
                y=ma200, 
                mode="lines", 
                name="MA 200", 
                line=dict(color="blue", width=2)
            ))

        fig.update_layout(
            title=f"{ticker} (Source: Kafka/Local)", 
            height=450, 
            template="plotly_dark"
        )
        st.plotly_chart(fig, use_container_width=True)

    except Exception as e:  
        st. error(f"Chart Error: {e}")
        
@st.cache_data(ttl=30)  # âœ… RÃ©duire le TTL Ã  30s pour plus de fraÃ®cheur
def get_sidebar_data() -> list[dict]:
    """Fetches latest intraday metrics from ChromaDB (via Kafka hot-news-events)."""
    results = []
    
    try:
        chroma_client = chromadb. PersistentClient(path=CHROMA_PATH)
        collection = chroma_client.get_collection(name=COLLECTION_NAME)
    except Exception as e:
        st.sidebar.warning(f"âš ï¸ ChromaDB unavailable: waiting for Kafka data...")
        return []
    
    for ticker in TICKERS:
        try:
            # âœ… PrioritÃ© aux mÃ©triques intraday (prix le plus rÃ©cent)
            results_chroma = collection.query(
                query_texts=[f"Momentum Intraday {ticker}"],
                where={
                    "$and": [
                        {"ticker":  {"$eq": ticker}},
                        {"type": {"$eq": "intraday_metrics"}}  # âœ… Filtrer sur le type
                    ]
                },
                n_results=1,
                include=["metadatas"]
            )
            
            if results_chroma["metadatas"] and results_chroma["metadatas"][0]: 
                meta = results_chroma["metadatas"][0][0]
                
                current_price = meta.get("current_price", 0)
                prev_close = meta.get("last_close", current_price)
                
                results.append({
                    "ticker": ticker,
                    "price": current_price,
                    "prev":  prev_close if prev_close else current_price,
                    "currency": meta.get("currency", "EUR"),
                    "market_state": meta.get("market_state", "CLOSED"),
                    "mean_50": meta.get("mean_50", 0),
                    "mean_200": meta.get("mean_200", 0),
                    "sentiment": meta.get("sentiment", 0),
                    "regularMarketTime": meta.get("regularMarketTime", 0)
                })
            else:
                # âœ… Ticker sans donnÃ©es = afficher placeholder
                results.append({
                    "ticker": ticker,
                    "price": 0,
                    "prev": 0,
                    "currency": "---",
                    "market_state": "WAITING",
                    "mean_50":  0,
                    "mean_200": 0,
                    "sentiment": 0,
                    "regularMarketTime":  0
                })
                
        except Exception as e: 
            print(f"[Sidebar] Error fetching {ticker}: {e}")
    
    return results

def display_sidebar() -> None:
    """Displays the sidebar with system status and market watch."""
    status, color = check_system_health()
    st.sidebar.markdown(f"### Pipeline Status:  :{color}[{status}]")
    
    if st.sidebar.button("ğŸ”„ Refresh Data"):
        get_sidebar_data. clear()  # âœ… Vider le cache
        st.rerun()
    
    st.sidebar.divider()
    st.sidebar.subheader("ğŸ“ˆ Market Watch")
    
    market_data = get_sidebar_data()
    
    for item in market_data:
        # âœ… GÃ©rer le cas "en attente"
        if item['market_state'] == "WAITING":
            st.sidebar.markdown(f"**{item['ticker']}** â³")
            st.sidebar.caption("En attente des donnÃ©es Kafka...")
            st.sidebar.divider()
            continue
        
        delta = ((item['price'] - item['prev']) / item['prev']) * 100 if item['prev'] else 0
        color_delta = "green" if delta >= 0 else "red"
        icon = "â–²" if delta >= 0 else "â–¼"
        
        market_indicator = "ğŸŸ¢" if item['market_state'] == "REGULAR" else "ğŸ”´"
        
        st.sidebar.markdown(f"**{item['ticker']}** {market_indicator}")
        st.sidebar. markdown(
            f"{item['price']:.4f} {item['currency']} :{color_delta}[{icon} {delta:.2f}%]"
        )
        
        # Date/heure du dernier prix
        try:
            last_price_time = item.get('regularMarketTime')
            if last_price_time and last_price_time > 0:
                from datetime import datetime
                dt = datetime.fromtimestamp(last_price_time)
                time_str = dt.strftime("%d/%m/%Y %H:%M")
            else:
                time_str = "N/A"
        except:
            time_str = "N/A"
        
        st.sidebar.caption(f"ğŸ“… {time_str}")
        st.sidebar.divider()
        
display_sidebar()

# --- MAIN LAYOUT ---
col1, col2 = st.columns([2, 1])

# --- MAIN LAYOUT ---
col1, col2 = st.columns([2, 1])

# âœ… Initialize session state for sources
if 'sources' not in st.session_state:
    st.session_state.sources = None
if 'answer' not in st.session_state:
    st.session_state.answer = None
if 'ticker' not in st.session_state:
    st.session_state.ticker = None

with col1:
    # --- AI ANALYST SECTION ---
    with st.container():
        st.markdown("### ğŸ¤– AI Market Analyst")
        with st.form(key="query_form"):
            query = st.text_input(
                "Ask about market trends, news, or technicals:",
                placeholder="Why is Stellantis dropping right now?"
            )
            submit = st.form_submit_button("Analyze", type="primary")

    if submit and query:
        with st.spinner("ğŸ§  Agent is analyzing Kafka streams..."):
            answer, sources, ticker, horizon = get_answer(query)
            
            st.session_state.sources = sources
            st.session_state.answer = answer
            st.session_state.ticker = ticker
            
            # Display Analysis Mode
            horizon_hours = round(horizon / 3600, 1)
            mode_label = "ğŸ”´ LIVE MODE" if horizon_hours < 4 else "ğŸ“š HISTORY MODE"
            st.caption(f"{mode_label} | Search Window: Last {horizon_hours} hours")
            
            # Display Answer
            st.success("âœ… Analysis Complete")
            st.markdown(answer)
            
            # Display Chart if ticker detected
            if ticker:
                st.divider()
                display_stock_chart(ticker)

# --- SOURCES PANEL ---
with col2:
    st.subheader("ğŸ“¡ Context Sources")
    
    # âœ… CHECK SESSION STATE INSTEAD OF LOCALS()
    if st.session_state.sources:
        for s in st.session_state.sources:
            # --- TECHNICAL ANALYSIS SOURCE ---
            if s['type'] == 'technical':   
                icon = "ğŸ“ˆ"
                relative_time = fmt_relative(s.get('timestamp'))
                
                # âœ… RÃ‰CUPÃ‰RER L'Ã‰TAT RÃ‰EL DU MARCHÃ‰
                try:
                    market_state = s.get('market_state', 'UKN')
                    if market_state == "REGULAR":
                        market_display = "ğŸŸ¢ OPEN"
                        market_color = "green"
                    else:
                        market_display = "ğŸ”´ CLOSED"
                        market_color = "red"
                except:
                    market_display = "â“ UNKNOWN"
                    market_color = "gray"
                
                with st.expander(f"{icon} {s['ticker']} - Technical Analysis ({relative_time})"):
                    # En-tÃªte compact
                    st.caption(f"ğŸ“… {s['date']} | :{market_color}[{market_display}]")

                    if s.get('regularMarketTime') and s['regularMarketTime'] != 0:
                        try:
                            dt = datetime.datetime.fromtimestamp(s['regularMarketTime'])
                            last_price_date = dt.strftime("%A %d/%m/%Y %H:%M")
                            st.caption(f"Last Price Update: {last_price_date}")
                        except:
                            pass

                    # âœ… CURRENT PRICES - Sans titre sÃ©parÃ©
                    price_parts = []
                    if s.get('current_price'):
                        price_parts.append(f"Current Price : {fmt(s['current_price'])} {s.get('currency', '')}")
                    if s.get('last_close'):
                        price_parts.append(f"Close: {fmt(s['last_close'])}")
                    if s.get('opening_price'):
                        price_parts.append(f"Open: {fmt(s['opening_price'])}")
                    if price_parts:
                        st. write(" | ".join(price_parts))
                    
                    # âœ… TECHNICAL LEVELS - Sur une ligne
                    ma_parts = []
                    if s. get('mean_10'):
                        ma_parts.append(f"MA10: {fmt(s['mean_10'])}")
                    if s.get('mean_50'):
                        ma_parts. append(f"MA50: {fmt(s['mean_50'])}")
                    if s.get('mean_200'):
                        ma_parts.append(f"MA200: {fmt(s['mean_200'])}")
                    if ma_parts:
                        st.write(" | ".join(ma_parts))
                    
                    # âœ… PRICE HISTORY - Sur une ligne
                    price_history = []
                    if s.get('price_12h_ago'): 
                        price_history.append(f"12h: {fmt(s['price_12h_ago'])}")
                    if s.get('price_6h_ago'): 
                        price_history.append(f"6h: {fmt(s['price_6h_ago'])}")
                    if s.get('price_3h_ago'): 
                        price_history.append(f"3h: {fmt(s['price_3h_ago'])}")
                    if s.get('price_1h_ago'): 
                        price_history.append(f"1h: {fmt(s['price_1h_ago'])}")
                    if s.get('price_30min_ago'): 
                        price_history.append(f"30m: {fmt(s['price_30min_ago'])}")
                    if s.get('price_10min_ago'): 
                        price_history.append(f"10m: {fmt(s['price_10min_ago'])}")
                    if price_history:
                        st.write(" | ".join(price_history))
                    
                    # âœ… LIEN - Minimal
                    if s.get('link') and s['link'] != "#":
                        st.markdown(f"[ğŸ“– Read more]({s['link']})")

            # --- NEWS SOURCE ---
            elif s['type'] == 'news':
                icon = "ğŸ“°"
                relative_time = fmt_relative(s.get('timestamp'))
                
                with st.expander(f"{icon} {s['ticker']} - News ({relative_time})"):
                    st.caption(f"ğŸ“… {s['date']}")
                    st.write(f"{s['title']}")
                    
                    # Sentiment Score with visual indicator
                    sentiment_score = s.get('sentiment')
                    if sentiment_score is not None and sentiment_score != "N/A":
                        try:
                            sentiment_float = float(sentiment_score)
                            # Color code sentiment
                            if sentiment_float > 0.5:
                                sentiment_label = "ğŸŸ¢ Positive"
                                sentiment_color = "green"
                            elif sentiment_float < -0.5:
                                sentiment_label = "ğŸ”´ Negative"
                                sentiment_color = "red"
                            else:  
                                sentiment_label = "âšª Neutral"
                                sentiment_color = "gray"
                            
                            st.write(f"**Sentiment:** :{sentiment_color}[{sentiment_label} ({sentiment_float:.2f})]")
                        except:
                            pass
                    
                    st.divider()
                    if s.get('link') and s['link'] != "#":
                        st.markdown(f"[ğŸ“– Read full article]({s['link']})")
            
            # --- INTRADAY METRICS SOURCE ---
            elif s['type'] == 'intraday_metrics':
                icon = "ğŸ“Š"
                relative_time = fmt_relative(s.get('timestamp'))
                try:
                    market_state = s.get('market_state', 'CLOSED')
                    if market_state == "REGULAR": 
                        market_display = "ğŸŸ¢ OPEN"
                    else:
                        market_display = "ğŸ”´ CLOSED"
                except:
                    market_display = "â“ UNKNOWN"
                
                with st.expander(f"{icon} {s['ticker']} - Intraday Metrics ({relative_time})"):
                    st.caption(f"ğŸ“… {s['date']} - Market: {market_display}")

                    if s.get('regularMarketTime') and s['regularMarketTime'] != 0:
                        try:
                            dt = datetime.datetime.fromtimestamp(s['regularMarketTime'])
                            last_price_date = dt.strftime("%A %d/%m/%Y %H:%M")
                            st.caption(f"Last Price Update: {last_price_date}")
                        except:
                            pass
                    
                    # âœ… Prix actuel avec vÃ©rification
                    current_price = s.get('current_price')
                    currency = s.get('currency', 'EUR')
                    
                    if current_price and current_price != 0:
                        st.markdown(f"**Momentum Analysis {s['ticker']} (Price: {float(current_price):.2f} {currency})**")
                    else:
                        st.markdown(f"**Momentum Analysis {s['ticker']}**")
                    
                    # âœ… Calcul et affichage des variations avec couleurs (mÃªme style que sidebar)
                    variations_data = [
                        ("10min", s.get('price_10min_ago')),
                        ("30min", s.get('price_30min_ago')),
                        ("1h", s.get('price_1h_ago')),
                        ("3h", s.get('price_3h_ago')),
                        ("6h", s.get('price_6h_ago')),
                    ]
                    
                    has_variations = False
                    for label, past_price in variations_data:
                        if past_price and past_price != 0 and current_price and current_price != 0:
                            var_pct = ((float(current_price) - float(past_price)) / float(past_price)) * 100
                            
                            # âœ… MÃªme logique que sidebar
                            color_var = "green" if var_pct >= 0 else "red"
                            icon_var = "â–²" if var_pct >= 0 else "â–¼"
                            
                            # âœ… Affichage avec couleur Streamlit
                            st.markdown(f"- {label}:  :{color_var}[{icon_var} {var_pct:.2f}%]")
                            has_variations = True
                    
                    # âœ… Message si pas de variations disponibles
                    if not has_variations:
                        st.caption("â³ Variations non disponibles")
                    
                    # Link minimal
                    if s.get('link') and s['link'] != "#":
                        st.markdown(f"[ğŸ“– View details]({s['link']})")
            
            else:
                st.info("ğŸ“Œ Sources will appear here after analysis.")
    else:
        st.info("ğŸ“Œ Sources will appear here after analysis.")